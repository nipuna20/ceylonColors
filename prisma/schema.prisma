generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  BUYER
  VENDOR
  ADMIN
}

enum OrderStatus {
  PENDING
  PAID
  PROCESSING
  SHIPPED
  COMPLETED
  CANCELLED
}

enum PayoutStatus {
  DUE
  PAID
  HOLD
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  passwordHash String
  role         Role     @default(BUYER)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  vendor          Vendor?   @relation("VendorOwner")
  approvedVendors Vendor[]  @relation("VendorApprover")
  orders          Order[]
  addresses       Address[]
  reviews         Review[]
  sessions        Session[] @relation("AuthSessions")
  accounts        Account[] @relation("AuthAccounts")
}

// EXTEND your existing Vendor model (add fields; keep existing ones)
model Vendor {
  id      String @id @default(cuid())
  ownerId String @unique
  owner   User   @relation("VendorOwner", fields: [ownerId], references: [id])

  shopName    String
  slug        String  @unique
  description String?
  logoUrl     String?
  coverUrl    String?

  // existing:
  isApproved    Boolean  @default(false)
  commissionPct Int      @default(10)
  createdAt     DateTime @default(now())

  // NEW – richer lifecycle / KYC / payout
  status       VendorStatus @default(PENDING)
  phone        String?
  addressLine1 String?
  addressLine2 String?
  city         String?
  taxId        String? // e.g., TIN/VAT
  brn          String? // business reg no
  website      String?

  payoutMethod    String? // "BANK"
  bankName        String?
  bankBranch      String?
  bankAccountName String?
  bankAccountNo   String?
  bankSwift       String?

  kycSubmittedAt  DateTime?
  approvedAt      DateTime?
  rejectedAt      DateTime?
  rejectionReason String?
  approvedById    String?
  approvedBy      User?     @relation("VendorApprover", fields: [approvedById], references: [id])

  documents VendorDocument[]

  products Product[]
  payouts  Payout[]
  orders   VendorOrder[]
}

model Category {
  id       String    @id @default(cuid())
  name     String    @unique
  slug     String    @unique
  products Product[]
}

model Product {
  id          String         @id @default(cuid())
  vendorId    String
  vendor      Vendor         @relation(fields: [vendorId], references: [id])
  title       String
  slug        String         @unique
  description String?
  priceCents  Int
  stock       Int            @default(0)
  categoryId  String?
  category    Category?      @relation(fields: [categoryId], references: [id])
  images      ProductImage[]
  active      Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  variants Variant[]
  reviews  Review[]

  // ✅ add this line
  orderItems OrderItem[]

  @@index([active, categoryId, vendorId])
  @@index([active, priceCents])
  @@index([active, createdAt])
}

model Variant {
  id              String  @id @default(cuid())
  productId       String
  product         Product @relation(fields: [productId], references: [id])
  name            String
  priceDeltaCents Int     @default(0)
  stock           Int     @default(0)

  // ✅ add this line
  orderItems OrderItem[]
}

model ProductImage {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])
  url       String
  alt       String?
  sort      Int     @default(0)
}

model Address {
  id        String  @id @default(cuid())
  userId    String
  user      User    @relation(fields: [userId], references: [id])
  line1     String
  line2     String?
  city      String
  postal    String?
  country   String  @default("LK")
  phone     String?
  isDefault Boolean @default(false)
}

model Order {
  id            String        @id @default(cuid())
  buyerId       String
  buyer         User          @relation(fields: [buyerId], references: [id])
  status        OrderStatus   @default(PENDING)
  totalCents    Int
  createdAt     DateTime      @default(now())
  items         OrderItem[]
  vendorOrders  VendorOrder[]
  paymentRef    String?
  shippingAddr  Json?
  paymentMethod PaymentMethod @default(COD)
  paidAt        DateTime?
  payment       Payment?
}

model OrderItem {
  id         String   @id @default(cuid())
  orderId    String
  order      Order    @relation(fields: [orderId], references: [id])
  productId  String
  product    Product  @relation(fields: [productId], references: [id])
  variantId  String?
  variant    Variant? @relation(fields: [variantId], references: [id])
  qty        Int
  priceCents Int
}

model VendorOrder {
  id                     String       @id @default(cuid())
  vendorId               String
  vendor                 Vendor       @relation(fields: [vendorId], references: [id])
  orderId                String
  order                  Order        @relation(fields: [orderId], references: [id])
  status                 OrderStatus  @default(PENDING)
  subtotalCents          Int
  payoutItems            PayoutItem[]
  codCommissionSettledAt DateTime? // when admin confirms they received the commission for COD
}

model Payout {
  id          String       @id @default(cuid())
  vendorId    String
  vendor      Vendor       @relation(fields: [vendorId], references: [id])
  amountCents Int
  status      PayoutStatus @default(DUE)
  periodStart DateTime
  periodEnd   DateTime
  createdAt   DateTime     @default(now())
  items       PayoutItem[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  user              User    @relation("AuthAccounts", fields: [userId], references: [id])
  type              String
  provider          String
  providerAccountId String
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation("AuthSessions", fields: [userId], references: [id])
  expires      DateTime
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Review {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
}

enum PaymentMethod {
  COD
  CARD
  HELAPAY
}

enum PaymentStatus {
  INITIATED
  CAPTURED
  PAID
  FAILED
  REFUNDED
}

model Payment {
  id          String        @id @default(cuid())
  orderId     String        @unique
  order       Order         @relation(fields: [orderId], references: [id])
  method      PaymentMethod
  gateway     String // e.g. "PAYHERE"
  amountCents Int
  status      PaymentStatus @default(INITIATED)
  externalRef String? // gateway order_id / payment_id
  raw         Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

// 1) Link vendor-order rows to payouts (so we never pay twice)
model PayoutItem {
  id            String      @id @default(cuid())
  payoutId      String
  payout        Payout      @relation(fields: [payoutId], references: [id])
  vendorOrderId String
  vendorOrder   VendorOrder @relation(fields: [vendorOrderId], references: [id])
  amountCents   Int
  createdAt     DateTime    @default(now())

  @@unique([vendorOrderId, payoutId])
}

// NEW
enum VendorStatus {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}

// NEW (optional but useful for evidence)
enum VendorDocType {
  BRN_CERT
  ID_FRONT
  ID_BACK
  BANK_STATEMENT
  OTHER
}

// NEW: store uploaded docs (you can wire to S3/Linode/etc later)
model VendorDocument {
  id       String @id @default(cuid())
  vendorId String
  vendor   Vendor @relation(fields: [vendorId], references: [id])

  type     VendorDocType
  url      String
  note     String?
  verified Boolean       @default(false)

  createdAt DateTime @default(now())
}
